set appTitle to "Running App"
-- This application uses iCal entries to track how many miles each sneaker has 
-- and the total miles for the month (for all sneakers)

-- I need to add another Calendar for each sneaker
-- Better to query for Calendars instead of needing to add one for each new sneaker
-- getListOfCalendars gets the calendars.

-- Can I use a global variable for total seconds so I don't have to iterate through the calendars twice?

set isDebug to 0

if isDebug is 0 then
	set runningCalendar1 to "T2"
	set runningCalendar2 to "red1"
	set runningCalendar3 to "brooksGreen"
	set runningCalendar4 to "flowRidder"
	
	set shoeWorn1 to runningCalendar1
	set shoeWorn2 to runningCalendar2
	set shoeWorn3 to runningCalendar3
	set shoeWorn4 to runningCalendar4
	
	set totalMiles1 to my findEvent(runningCalendar1, shoeWorn1)
	set totalMiles2 to my findEvent(runningCalendar2, shoeWorn2)
	set totalMiles3 to my findEvent(runningCalendar3, shoeWorn3)
	set totalMiles4 to my findEvent(runningCalendar4, shoeWorn4)
	
	set message1 to my dialogText(shoeWorn1, totalMiles1)
	set message2 to my dialogText(shoeWorn2, totalMiles2)
	set message3 to my dialogText(shoeWorn3, totalMiles3)
	set message4 to my dialogText(shoeWorn4, totalMiles4)
	
	set SecondsRun1 to my getSecondsInMonth(runningCalendar1)
	set SecondsRun2 to my getSecondsInMonth(runningCalendar2)
	set SecondsRun3 to my getSecondsInMonth(runningCalendar3)
	set SecondsRun4 to my getSecondsInMonth(runningCalendar4)
	
	set milesRun1 to my getMilesInMonth(runningCalendar1)
	set milesRun2 to my getMilesInMonth(runningCalendar2)
	set milesRun3 to my getMilesInMonth(runningCalendar3)
	set milesRun4 to my getMilesInMonth(runningCalendar4)
	
	set totalDistance to (milesRun1 + milesRun2 + milesRun3 + milesRun4)
	set totalTime to (SecondsRun1 + SecondsRun2 + SecondsRun3 + SecondsRun4)
	
	set pace to 0
	if totalDistance is not 0 then
		set pace to (totalTime / totalDistance)
	end if
	set monthPace to (my getHMS(pace))
	
	set messageTotalMiles to "Miles for the month: " & totalDistance
	set messageTotalSeconds to "Time for the month: " & (my getHMS(totalTime))
	set messageMonthPace to "Month pace: " & monthPace
	
	--add another line that gets the month pace
	
	set messageTotalMiles to messageTotalMiles
	set combinedMessage to messageTotalMiles
	
	set combinedMessage to message1 & "
" & message2 & "
" & message3 & "
" & message4 & "

" & messageTotalMiles & "
" & messageTotalSeconds & "
" & messageMonthPace
	display dialog combinedMessage buttons {"OK", "Cancel"} default button "OK" with title appTitle
else
	
	set totalDistance to 10
	set totalTime to ((74 * 60) + (15)) -- 4440 + 15 = 4455
	set pace to 0
	if totalDistance is not 0 then
		set pace to (totalTime / totalDistance)
	end if
	--rounding errors in getHMS -- 445.5 is not properly converted to h m s	
	set monthPace to (my getHMS(pace))
	set message to "Month pace: " & monthPace
	display dialog message buttons {"OK", "Cancel"} default button "OK" with title appTitle
	
end if
-- here on are the functions to do all the calculations ---------------------

-- if it can't access the array item, return -1
on getArrayItem(myArray, location)
	try
		set x to item location in myArray
		return x
	on error errText number errNum
		return -1
	end try
end getArrayItem

-- gets all the miles for a particular running shoe calendar
on getMilesInMonth(calendarName)
	
	set {year:y, month:m, day:d} to current date
	set str to (m as string) & " " & (d as string) & " " & (y as string)
	set today to date str
	
	set fdate to "(" & m & "/1/" & y & ")" as string
	set firstDayOfMonth to date fdate
	
	set tomorrow to today + 60 * 60 * 24
	
	set returnV to 0
	
	tell application "iCal"
		tell calendar calendarName
			set curr to every event whose start date is greater than or equal to firstDayOfMonth and start date is less than or equal to tomorrow
			set val to 0
			repeat with an_event in curr
				set myTestString to my theSplit(summary of an_event, "-")
				set returnV to val + (my getArrayItem(my theSplit(myTestString, "-"), 1))
				set val to returnV
				
			end repeat
		end tell
	end tell
	return returnV
	
end getMilesInMonth

on getSecondsInMonth(calendarName)
	
	set {year:y, month:m, day:d} to current date
	set str to (m as string) & " " & (d as string) & " " & (y as string)
	set today to date str
	
	set fdate to "(" & m & "/1/" & y & ")" as string -- test using march
	set firstDayOfMonth to date fdate
	
	set tomorrow to today + 60 * 60 * 24
	
	set returnV to 0
	
	tell application "iCal"
		tell calendar calendarName
			set curr to every event whose start date is greater than or equal to firstDayOfMonth and start date is less than or equal to tomorrow
			set val to 0
			set totalSeconds to 0
			repeat with an_event in curr
				set myTestString to my theSplit(summary of an_event, "-")
				
				set getTime to (my getArrayItem(myTestString, 3))
				
				set myHMS to my theSplit(getTime, ":")
				set hour to 0
				set secs to 0
				set mins to 0
				
				set secs to (my getArrayItem(myHMS, 3)) --30				
				if secs is -1 then
					--no hour
					set secs to (my getArrayItem(myHMS, 2)) --30				
					if secs is -1 then
						--no minutes
						set secs to (my getArrayItem(myHMS, 1)) --30				
					else
						set mins to (my getArrayItem(myHMS, 1)) --37
					end if
				else
					set hour to (my getArrayItem(myHMS, 1)) --1
					set mins to (my getArrayItem(myHMS, 2)) --37
					set secs to (my getArrayItem(myHMS, 3)) --30
					
				end if
				
				set totalSeconds to (totalSeconds + ((hour * 3600) + (mins * 60) + secs)) --5850 + 2145 = 7995
			end repeat
		end tell
	end tell
	return totalSeconds
	
end getSecondsInMonth

--convert seconds to h m s
on getHMS(totalSeconds)
	
	set mins to 0
	set secs to 0
	set hour to 0
	
	set mins to (totalSeconds / 60)
	set mins to (my truncate(mins, 0))
	set secs to (totalSeconds - (mins * 60))
	repeat while mins > 59
		set hour to (hour + 1)
		set mins to (mins - 60)
	end repeat
	
	set hour to (my truncate(hour, 0))
	set mins to (my truncate(mins, 0))
	set secs to (my truncate(secs, 0))
	
	if mins < 10 then
		set mins to "0" & mins
	end if
	if secs < 10 then
		set secs to "0" & secs
	end if
	
	set convertSeconds to ("" & hour & ":" & mins & ":" & secs)
	return convertSeconds
end getHMS


on truncate(aNumber, decimalPlaces)
	
	set aNumeral to "" & aNumber
	
	if aNumeral does not contain "." then
		set aNumeral to aNumeral & "."
	end if
	
	repeat with i from 1 to decimalPlaces
		set aNumeral to aNumeral & "0"
	end repeat
	
	repeat with i from 1 to length of aNumeral
		if characters i thru -1 of aNumeral does not contain "." then exit repeat
	end repeat
	try
		return (characters (1) thru (i + (decimalPlaces - 1)) of aNumeral as string) + 0
	end try
end truncate

--returns an array of events for a calendar
--not sure if it's doing all
--need to find the properties of event
--need to iterate through the events of a calendar.
--looks for myCalendar, parses the summary to look for the first item before the dash and totals that value for all events
--returns the total 
on findEvent(myCalendar, shoeName)
	set eventArray to ""
	tell application "iCal"
		tell calendar myCalendar
			set the_events to every event
			set val to 0
			repeat with an_event in the_events
				--parse
				set myTestString to my theSplit(summary of an_event, "-")
				set shoe to my getArrayItem(my theSplit(myTestString, "-"), 2)
				
				set returnV to val + (my getArrayItem(my theSplit(myTestString, "-"), 1))
				set val to returnV
			end repeat
			
			set theEvent to first event
			set eventArray to eventArray & " " & uid of theEvent
		end tell
	end tell
	return returnV
end findEvent

on theSplit(theString, theDelimiter)
	-- save delimiters to restore old settings
	set oldDelimiters to AppleScript's text item delimiters
	-- set delimiters to delimiter to be used
	set AppleScript's text item delimiters to theDelimiter
	-- create the array
	set theArray to every text item of theString
	-- restore the old setting
	set AppleScript's text item delimiters to oldDelimiters
	-- return the result
	return theArray
end theSplit

on showEvent(myCalendar)
	tell application "iCal"
		tell calendar myCalendar
			set theEvent to first event
			--show theEvent -- show pops it up in the calendar
		end tell
	end tell
	
end showEvent

on getListOfCalendars()
	
	tell application "iCal"
		set theCalendarNames to title of every calendar
	end tell
	return theCalendarNames
end getListOfCalendars

on dialogText(shoe, miles)
	set milesAsNum to my int_2_string(milesRun, 10)
	return shoe & " did " & milesAsNum
end dialogText

on int_2_string(the_int, base)
	set digit_string to "0123456789ABCDEF"
	set the_int to the_int div 1 -- cut off decimals if a float
	set e to 0
	
	set r to ""
	repeat while the_int > 0
		set d to (the_int mod base)
		set d to item (d + 1) of digit_string
		set r to d & r
		set e to e + 1
		set the_int to the_int div base
	end repeat
	if r = "" then
		set r to "0"
	end if
	return r
end int_2_string

on number_to_string(this_number)
	set this_number to this_number as string
	if this_number contains "E+" then
		set x to the offset of "." in this_number
		set y to the offset of "+" in this_number
		set z to the offset of "E" in this_number
		-- github doesn't recognize the special character (¬)  by typing option-L
		set the decimal_adjust to characters (y - (length of this_number)) thru Â
			-1 of this_number as string as number
		if x is not 0 then
			set the first_part to characters 1 thru (x - 1) of this_number as string
		else
			set the first_part to ""
		end if
		set the second_part to characters (x + 1) thru (z - 1) of this_number as string
		set the converted_number to the first_part
		repeat with i from 1 to the decimal_adjust
			try
				-- github doesn't recognize the special character by typing option-L
				set the converted_number to Â
					the converted_number & character i of the second_part
			on error
				set the converted_number to the converted_number & "0"
			end try
		end repeat
		return the converted_number
	else
		return this_number
	end if
end number_to_string

on write_to_file(this_data, target_file, append_data)
	try
		set the target_file to the target_file as text
		set the open_target_file to Â
			open for access file target_file with write permission
		if append_data is false then Â
			set eof of the open_target_file to 0
		write this_data to the open_target_file starting at eof
		close access the open_target_file
		return true
	on error
		try
			close access file target_file
		end try
		return false
	end try
end write_to_file

on WriteLog(the_text)
	set this_story to the_text
	set this_file to (((path to desktop folder) as text) & "My Running Log")
	my write_to_file(this_story, this_file, true)
end WriteLog

